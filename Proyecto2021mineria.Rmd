---
title: "Proyecto 1 Mineria de datos"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list=ls())
library(dplyr)
library(utf8)
library("ggplot2")
library(stringr)
library(tidyverse)
library(pillar)
library("psych")
library("car")
library("Hmisc")
library("corrplot")
library("recommenderlab")
```

```{r}
setwd('/Users/amara/Documents/GitHub/Mineria-de-datos-2021')
sanguchez <- read.csv("sanguchez.csv", sep=';')
#sanguchez <- read.csv("sanguchez.csv", sep=";",stringsAsFactors=TRUE)

```

```{r}
# limpiamos la data de los NA y de los vacíos:
sanguchez = na.omit(sanguchez)

#nos quedamos solo con los que tenga peso ($):
sanguchez <- filter(sanguchez, str_detect(sanguchez$Precio,"\\$")==T)

#Cambiamos todos los espacios vacíos que tengamos al inicio y al final por nada 
#de cada Precio:
sanguchez$Precio = str_replace_all(sanguchez$Precio, "^ ", "")
sanguchez$Precio = str_replace_all(sanguchez$Precio, " $", "")

#aplicamos attach para seguir tratando las columnas:
attach(sanguchez)
#Sacaremos aquellos precios que muestran mas de un precio por el hecho que vengan con
#otra moneda inicial
#cbind(Precio,str_count(Precio, "\\$"),str_count(Precio, " "))
# para lo anterior nos quedaremos solo con los precios que no tengan espacios
#y que solo tengan y solo signo peso, las eliminamos :

sanguchez <- filter(sanguchez, str_count(Precio, "\\$")==1 &  str_count(Precio," ")==0)

#Finalmente le quitamos los puntos y el signo peso, para que solo queden los números en 
#precio y podamos transformar la columna a entero:

attach(sanguchez)
sanguchez$Precio = str_replace_all(sanguchez$Precio, "\\$", "")
sanguchez$Precio = str_replace_all(sanguchez$Precio, "\\.", "")

sanguchez$Precio = as.integer(sanguchez$Precio) 

```
```{r}
# Luego, obtenemos las columnas que nos puedan ayudar, por ejemplo si en el texto tenemos 
# bueno, malo, rico o peor, seleccionamos estas palabras ya que son adjetivos representativos de lo que estamos intentando #identificar en el comentario de cada hamburguesa.

sanguchez$Bueno = str_detect(texto,"(b|B)(u|U)(e|E)(n|N)(o|O)")
sanguchez$Bueno = as.numeric(sanguchez$Bueno)

sanguchez$Rico = str_detect(texto,"(r|R)(i|I)(c|C)(o|O)")
sanguchez$Rico = as.numeric(sanguchez$Rico)
 
sanguchez$Malo = str_detect(texto,"(m|M)(a|A)(l|L)(o|O)")
sanguchez$Malo = as.numeric(sanguchez$Malo)

sanguchez$Peor = str_detect(texto,"(p|P)(e|E)(o|O)(r|R)")
sanguchez$Peor = as.numeric(sanguchez$Peor)

#Creamos dos variables, suma1 que sera representara si es que tiene un buen comentario y suma2 si tiene uno malo.
sanguchez$suma1 = sanguchez$Rico + sanguchez$Bueno
sanguchez$suma1 = as.numeric(sanguchez$suma1)

sanguchez$suma2 = sanguchez$Malo + sanguchez$Peor
sanguchez$suma2 = as.numeric(sanguchez$suma2)

# Eliminamos la columna de texto, ya que extrajimos la información que necesitabamos de ello.
sanguchez<-sanguchez[,-7]
colnames(sanguchez)

summary(sanguchez)

hist(sanguchez$Malo)
hist(sanguchez$Bueno)
hist(sanguchez$Rico)
hist(sanguchez$Peor)
hist(sanguchez$suma1)
hist(sanguchez$suma2)

#install.packages("corrplot")
# cor(sanguchez[,c(6,7,8,9)])
# corr.test(sanguchez[,c(6,7,8,9)],use="complete")


```
```{r}
attach(sanguchez)

# A continuación, extraeremos la cantidad de ingredientes de cada hamburguesa.
L_ingredientes = 
  strsplit(str_replace_all(sanguchez$Ingredientes,"(,.y|,y)",","),"( y |,)")

L = lapply(L_ingredientes,length)
L = as.numeric(L)

#Aquí pegamos la columna "cantidad_ingredientes" a la base de datos.
sanguchez$cantidad_ingredientes = L

#En primer lugar, obtenemos el máximo de cantidad de ingredientes.
max(sanguchez$cantidad_ingredientes)

#Luego, revela los ingredientes de la hamburguesa que tiene la mayor cantidad.
 sanguchez[which.max(sanguchez$cantidad_ingredientes),"Ingredientes"]

#A continuación mostramos la ubicación de la hamburguesa, es decir, en que fila se encuentra.
which.max(sanguchez$cantidad_ingredientes)

#Finalmente, enumera los ingredientes mostrando como fueron separados.
 L_ingredientes[which.max(sanguchez$cantidad_ingredientes)]

```

```{r}
#A partir de la limpieza de la base de datos realizada con anterioridad, damos paso a realizar diferentes representaciones gráficas de los datos.
attach(sanguchez)

#A partir de la función summary obtenemos distintas métricas de cada variable
summary(sanguchez)
colnames(sanguchez)

plot(nota,cantidad_ingredientes)
boxplot(cantidad_ingredientes)
plot(nota,cantidad_ingredientes)
#ggplot ( Precio , aes ( x = x , color = data)) + 
#    geom_boxplot () + 
#    theme_void () + 
#    theme ( legend.position  =  " none " ) + 
#    facet_wrap ( ~ data, ncol = 3 )

```


```{r}
# Correlación de pearson: 
cor(x = cbind(Precio,nota,cantidad_ingredientes,suma1, suma2), method = "pearson")
cor.plot(cbind(Precio,nota,cantidad_ingredientes, suma1, suma2))
pairs(cbind(Precio,nota,cantidad_ingredientes, suma1, suma2))
```

```{r}
#install.packages("quanteda")
library("quanteda")


# contamos palabra por palabra para los ingredientes:
ingre <- sanguchez$Ingredientes
ingre <- char_tolower(ingre)
ingre <- iconv(ingre, to = "ASCII//TRANSLIT")
b <- dfm(ingre, remove = c(stopwords("es")))
df_b = convert(b, to= "data.frame")
# reiniciamos los indices de los sanguchez
row.names(sanguchez) = NULL

# sacamos los signos que no nos aportan
df_b = df_b[,!names(df_b) %in% c("doc_id",",","!","?")]


```
```{r}
# creamos el DF definitivo con todo lo anterior y ademas lo limpiamos de
# columnas que no nos interesan donde salen como parte de los ingredientes:
DF = cbind(sanguchez,df_b)
columnas_sacar = c("170","250","by","225","vacia3","20","185","a3n","/","%","220","300",
                   "\"" ,"(","230","1", ")","3","120","180",".","2","mah","175","340","5","100",
                   "200","ra","suma")
DF = DF[,!names(DF) %in% columnas_sacar]

# str(DF)
# obtenemos la suma que tendra el total de cada ingrediente:
DF_ingre = DF[,c(14:356)]
# Así se debe ocupar el order de manera correcta:
S = colSums(DF_ingre)
# con S reordenamos las columnas de DF_ingre:
DF_ingre = DF_ingre[,order(S,decreasing = T)]
S = S[order(S,decreasing = T)]
# ya con DF_ingre ordenado por cada ingrediente, podemos ahora ordenar
# DF para que los ingredientes a partir de la columna 11, puedan estar
# ordenados de mayor a menor por la cantidad de veces que sale cada uno en total
# de todas las hamburguesas:
# por ejemplo los 5 mas aparecidos con las veces de cada uno:
S[c(1:10)]
# ahora si reemplazamos DF[,c(14:356)] por DF_ingre y además ajustamos los

DF[,c(14:356)] = DF_ingre
col_iniciales = names(DF[1:13])
col_total = c(col_iniciales,c(names(DF_ingre)))
names(DF) = col_total

DF[,c(14:356)] = DF[,c(names(DF_ingre))]
names(DF[14]) = c(names(DF_ingre))[1]
col_iniciales = names(DF[1:13])
col_total = c(col_iniciales,c(names(DF_ingre)))
```
```{r}
#install.packages("tidyverse")
library("tidyverse")
glimpse(DF)
DF[,c(14:50)] %>%
  gather(key = "variable", value = "valor") %>%
  filter(valor != 0) %>% group_by(variable) %>%
  count() %>% 
  ggplot(aes(x =  reorder(variable, desc(n)), y = n)) +
  geom_col() +
  theme_bw() +
  labs(x = "Ingrediente") +
  theme(axis.text.x = element_text(angle = 90))
```

```{r}
# Ahora filtraremos si la nota es menor a 3 y los comnetarios digan peor y malo.
df_3 = filter(DF,nota<3, suma2 == 2, suma1 == 0)

glimpse(df_3)
df_3[,c(14:50)] %>%
  gather(key = "variable", value = "valor") %>%
  filter(valor != 0) %>% group_by(variable) %>%
  count() %>% 
  ggplot(aes(x =  reorder(variable, desc(n)), y = n)) +
  geom_col() +
  theme_bw() +
  labs(x = "Ingrediente") +
  theme(axis.text.x = element_text(angle = 90))
```

```{r}
# Ahora filtraremos si la nota es mayor a 3 y los comnetarios digan bueno y rico.
df_4 = filter(DF,nota>3, suma1 == 2, suma2 == 0)

glimpse(df_4)
df_4[,c(14:50)] %>%
  gather(key = "variable", value = "valor") %>%
  filter(valor != 0) %>% group_by(variable) %>%
  count() %>% 
  ggplot(aes(x =  reorder(variable, desc(n)), y = n)) +
  geom_col() +
  theme_bw() +
  labs(x = "Ingrediente") +
  theme(axis.text.x = element_text(angle = 90))
```

```{r}
?mahalanobis
#DETECCIÓN DE OUTLIERS
# Obtenemos los datos de mahalnobis con una escala de [0,1]
sanguchez$mah = mahalanobis(cbind(Precio/max(Precio),nota/max(nota),cantidad_ingredientes/max(cantidad_ingredientes),suma1/max(suma1), suma2/max(suma2)) ,
                            colMeans(cbind(Precio/max(Precio),nota/max(nota),cantidad_ingredientes/max(cantidad_ingredientes),suma1/max(suma1), suma2/max(suma2))),
                            cov(cbind(cbind(Precio/max(Precio),nota/max(nota),cantidad_ingredientes/max(cantidad_ingredientes),suma1/max(suma1), suma2/max(suma2)))))


hist(sanguchez$mah)
plot(Precio,sanguchez$mah)
plot(nota,sanguchez$mah)

# Generar un vector boleano los dos valores más alejados segun la distancia Mahalanobis.
outlier2 <- rep(FALSE , nrow(cbind(Precio,nota)))
# Determinar el número de outlier que queremos encontrar.
num.outliers= 30
outlier2[sanguchez$mah[1:num.outliers]] <- TRUE
# Resaltar con un punto relleno los 2 valores outliers.
colorear.outlier <- outlier2 * 16
```

```{r}
max(sanguchez$mah)
min(sanguchez$mah)
plot(c(1:358),sanguchez$mah)
```

```{r}
#Estandarizar, promedio, varianza, rotación
apply(X = DF[,c(4,6,11,12,13)], MARGIN = 2, FUN = mean)

apply(X = DF[,c(4,6,11,12,13)], MARGIN = 2, FUN = var)

pca <- prcomp(DF[,c(4,6,11,12,13)], scale = TRUE)
names(pca)

pca$center

pca$scale

pca$rotation

head(pca$x)

dim(pca$x)

#graficar
biplot(x = pca, scale = 0, cex = 0.6, col = c("blue4", "brown3"))
#varianza explicada
pca$sdev^2

prop_varianza <- pca$sdev^2 / sum(pca$sdev^2)
prop_varianza

#graficar
ggplot(data = data.frame(prop_varianza, pc = 1:5 ),
       aes(x = pc, y = prop_varianza)) +
  geom_col(width = 0.3) +
  scale_y_continuous(limits = c(0,1)) +
  theme_bw() +
  labs(x = "Componente principal",
       y = "Prop. de varianza explicada")

prop_varianza_acum <- cumsum(prop_varianza)
prop_varianza_acum


ggplot(data = data.frame(prop_varianza_acum, pc = 1:5),
       aes(x = pc, y = prop_varianza_acum, group = 1)) +
  geom_point() +
  geom_line() +
  theme_bw() +
  labs(x = "Componente principal",
       y = "Prop. varianza explicada acumulada")

```

```{r}
# entropia euclidiana
d = dist(x = cbind(Precio,nota), method = "euclidean")
class(d)
```

```{r}
# pearson
cor(x = cbind(Precio,nota,cantidad_ingredientes,suma1, suma2), method = "pearson")
cor.plot(cbind(Precio,nota,cantidad_ingredientes, suma1, suma2))

pairs(cbind(Precio,nota,cantidad_ingredientes, suma1, suma2))
```

```{r}
# similitud coseno:
# Coseno
coseno <- function(x, y){
  resultado <- x%*%y / (sqrt(x %*% x) * sqrt(y %*%y ))
  return(as.numeric(resultado))
}

coseno(Precio,nota)
# Coseno tras centrar los vectores
a <- Precio - mean(Precio)
b <- nota - mean(nota)
coseno(a,b)
```

```{r}

```

